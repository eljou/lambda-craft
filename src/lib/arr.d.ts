import { Maybe } from './maybe.js'
import { Either } from './either.js'
import { Task } from './task.js'

/**
 * Creates an array from the given arguments.
 * @template T
 * @param {...T} args - The elements to include in the array.
 * @returns {T[]} - An array containing the given elements.
 */
declare function of<T>(...args: T[]): T[]

// ---
/**
 * Creates an array of a specified length filled with the specified element.
 * @template A
 * @param {number} n - The length of the array to create.
 * @param {A} element - The element to fill the array with.
 * @returns {A[]} - An array of length n filled with the specified element.
 */
declare function make<A>(n: number, element: A): A[]

/**
 * Creates an array of a specified length filled with the specified element (curried version).
 * @template A
 * @param {A} element - The element to fill the array with.
 * @returns {(n: number) => A[]} - A curried function that takes a number and returns an array of that length filled with the specified element.
 */
declare function make<A>(element: A): (n: number) => A[]

// ---
/**
 * Creates an array of a specified length filled with elements generated by the map function.
 * @template A
 * @param {number} n - The length of the array to create.
 * @param {(idx: number) => A} mapFn - The function to generate elements for the array.
 * @returns {A[]} - An array of length n filled with elements generated by the map function.
 */
declare function makeWithIndex<A>(n: number, mapFn: (idx: number) => A): A[]

/**
 * Creates an array of a specified length filled with elements generated by the map function (curried version).
 * @template A
 * @param {(idx: number) => A} mapFn - The function to generate elements for the array.
 * @returns {(n: number) => A[]} - A curried function that takes a number and returns an array of that length filled with elements generated by the map function.
 */
declare function makeWithIndex<A>(mapFn: (idx: number) => A): (n: number) => A[]

// ---
/**
 * Checks if the given array is empty.
 * @template A
 * @param {A[]} arr - The array to check for emptiness.
 * @returns {boolean} - True if the array is empty, false otherwise.
 */
declare function isEmpty<A>(arr: A[]): boolean

// ---
/**
 * Returns the size of the given array.
 * @template T
 * @param {T[]} list - The array for which to determine the size.
 * @returns {number} - The size of the array.
 */
declare function size<T>(list: T[]): number

// ---
/**
 * Returns the first element of the given array, wrapped in a Maybe type.
 * @template T
 * @param {T[]} arr - The array from which to retrieve the first element.
 * @returns {Maybe<T>} - The first element of the array, wrapped in a Maybe type.
 */
declare function head<T>(arr: T[]): Maybe<T>

// ---
/**
 * Returns the first element of the given array, or null if the array is empty.
 * @template T
 * @param {T[]} arr - The array from which to retrieve the first element.
 * @returns {T | undefined} - The first element of the array, or undefined if the array is empty.
 */
declare function headOrNull<T>(arr: T[]): T | undefined

// ---
/**
 * Returns a new array containing all elements of the given array except the first one.
 * @template T
 * @param {T[]} arr - The array from which to remove the first element.
 * @returns {T[]} - A new array containing all elements of the given array except the first one.
 */
declare function tail<T>(arr: T[]): T[]

// ---
/**
 * Check if all elements in the array pass the predicate function.
 * @template A
 * @param {A[]} arr - The input array.
 * @param {(item: A) => boolean} predicateFn - The predicate function.
 * @returns {boolean} - Returns true if all elements pass the predicate function, otherwise false.
 */
declare function all<A>(arr: A[], predicateFn: (item: A) => boolean): boolean

/**
 * Check if all elements in the array pass the predicate function (curried version).
 * @template A
 * @param {(item: A) => boolean} predicateFn - The predicate function.
 * @returns {(arr: A[]) => boolean} - Returns a function that checks if all elements in the array pass the predicate function.
 */
declare function all<A>(predicateFn: (item: A) => boolean): (arr: A[]) => boolean

// ---
/**
 * Check if any element in the array passes the predicate function.
 * @template A
 * @param {A[]} arr - The input array.
 * @param {(item: A) => boolean} predicateFn - The predicate function.
 * @returns {boolean} - Returns true if any element passes the predicate function, otherwise false.
 */
declare function any<A>(arr: A[], predicateFn: (item: A) => boolean): boolean

/**
 * Check if any element in the array passes the predicate function (curried version).
 * @template A
 * @param {(item: A) => boolean} predicateFn - The predicate function.
 * @returns {(arr: A[]) => boolean} - Returns a function that checks if any element in the array passes the predicate function.
 */
declare function any<A>(predicateFn: (item: A) => boolean): (arr: A[]) => boolean

// ---
/**
 * Check if some elements in the array pass the predicate function.
 * @template T
 * @param {T[]} list - The input array.
 * @param {(val: T) => boolean} predicate - The predicate function.
 * @returns {boolean} - Returns true if some elements pass the predicate function, otherwise false.
 */
declare function some<T>(list: T[], predicate: (val: T) => boolean): boolean

/**
 * Check if some elements in the array pass the predicate function (curried version).
 * @template T
 * @param {(val: T) => boolean} predicate - The predicate function.
 * @returns {(list: T[]) => boolean} - Returns a function that checks if some elements in the array pass the predicate function.
 */
declare function some<T>(predicate: (val: T) => boolean): (list: T[]) => boolean

// ---
/**
 * Find the first element in the array that passes the predicate function.
 * @template T
 * @param {T[]} list - The input array.
 * @param {(val: T) => boolean} predicate - The predicate function.
 * @returns {Maybe<T>} - Returns the first element that passes the predicate function, or Maybe<T> if not found.
 */
declare function find<T>(list: T[], predicate: (val: T) => boolean): Maybe<T>

/**
 * Find the first element in the array that passes the predicate function (curried version).
 * @template T
 * @param {(val: T) => boolean} predicate - The predicate function.
 * @returns {(list: T[]) => Maybe<T>} - Returns a function that finds the first element in the array that passes the predicate function.
 */
declare function find<T>(predicate: (val: T) => boolean): (list: T[]) => Maybe<T>

// ---
/**
 * Find the first element in the array that passes the predicate function or return null if not found.
 * @template T
 * @param {T[]} list - The input array.
 * @param {(val: T) => boolean} predicate - The predicate function.
 * @returns {T | null} - Returns the first element that passes the predicate function, or null if not found.
 */
declare function findOrNull<T>(list: T[], predicate: (val: T) => boolean): T | null

/**
 * Find the first element in the array that passes the predicate function or return null if not found (curried version).
 * @template T
 * @param {(val: T) => boolean} predicate - The predicate function.
 * @returns {(list: T[]) => T | null} - Returns a function that finds the first element in the array that passes the predicate function or returns null if not found.
 */
declare function findOrNull<T>(predicate: (val: T) => boolean): (list: T[]) => T | null

// ---
/**
 * Get the element at the specified index in the array or return Maybe<T>.
 * @template T
 * @param {T[]} list - The input array.
 * @param {number} i - The index.
 * @returns {Maybe<T>} - Returns the element at the specified index, or Maybe<T> if not found.
 */
declare function at<T>(list: T[], i: number): Maybe<T>

/**
 * Get the element at the specified index in the array or return Maybe<T> (curried version).
 * @template T
 * @param {number} i - The index.
 * @returns {(list: T[]) => Maybe<T>} - Returns a function that gets the element at the specified index in the array or returns Maybe<T>.
 */
declare function at<T>(i: number): (list: T[]) => Maybe<T>

// ---
/**
 * Get the element at the specified index in the array or return null if not found.
 * @template T
 * @param {T[]} list - The input array.
 * @param {number} i - The index.
 * @returns {T | null} - Returns the element at the specified index, or null if not found.
 */
declare function atOrNull<T>(list: T[], i: number): T | null

/**
 * Get the element at the specified index in the array or return null if not found (curried version).
 * @template T
 * @param {number} i - The index.
 * @returns {(list: T[]) => T | null} - Returns a function that gets the element at the specified index in the array or returns null if not found.
 */
declare function atOrNull<T>(i: number): (list: T[]) => T | null

// ---
/**
 * Remove the element at the specified index in the array.
 * @template A
 * @param {A[]} arr - The input array.
 * @param {number} index - The index.
 * @returns {A[]} - Returns the array with the element at the specified index removed.
 */
declare function removeAt<A>(arr: A[], index: number): A[]

/**
 * Remove the element at the specified index in the array (curried version).
 * @template A
 * @param {number} index - The index.
 * @returns {(arr: A[]) => A[]} - Returns a function that removes the element at the specified index in the array.
 */
declare function removeAt<A>(index: number): (arr: A[]) => A[]

// ---
/**
 * Takes the first n elements from the input array.
 * @template A
 * @param {A[]} arr - The input array.
 * @param {number} n - The number of elements to take.
 * @returns {A[]} - The new array containing the first n elements of the input array.
 */
declare function take<A>(arr: A[], n: number): A[]

/**
 * Takes the first n elements from the input array (curried version).
 * @template A
 * @param {number} n - The number of elements to take.
 * @returns {(arr: A[]) => A[]} - A function that takes an array and returns a new array containing the first n elements.
 */
declare function take<A>(n: number): (arr: A[]) => A[]

// ---
/**
 * Reverses the elements of the input array.
 * @template T
 * @param {T[]} arr - The input array.
 * @returns {T[]} - The new array with elements in reverse order.
 */
declare function reverse<T>(arr: T[]): T[]

// ---
/**
 * Adds an element to the beginning of the input array.
 * @template T
 * @param {T[]} arr - The input array.
 * @param {T} item - The element to add to the array.
 * @returns {T[]} - The updated array with the new element added to the beginning.
 */
declare function cons<T>(arr: T[], item: T): T[]

/**
 * Adds an element to the beginning of the input array (curried version).
 * @template T
 * @param {T} item - The element to add to the array.
 * @returns {(arr: T[]) => T[]} - A function that takes an array and returns the updated array with the new element added to the beginning.
 */
declare function cons<T>(item: T): (arr: T[]) => T[]

// ---
/**
 * Adds an element to the end of the input array.
 * @template T
 * @param {T[]} arr - The input array.
 * @param {T} item - The element to add to the array.
 * @returns {T[]} - The updated array with the new element added to the end.
 */
declare function snoc<T>(arr: T[], item: T): T[]

/**
 * Adds an element to the end of the input array (curried version).
 * @template T
 * @param {T} item - The element to add to the array.
 * @returns {(arr: T[]) => T[]} - A function that takes an array and returns the updated array with the new element added to the end.
 */
declare function snoc<T>(item: T): (arr: T[]) => T[]

// ---
/**
 * Concatenates two arrays and returns a new array containing the elements of both input arrays.
 * @template T
 * @param {T[]} arrA - The first input array.
 * @param {T[]} arrB - The second input array.
 * @returns {T[]} - The new array containing elements from both input arrays.
 */
declare function concat<T>(arrA: T[], arrB: T[]): T[]

/**
 * Concatenates two arrays and returns a new array containing the elements of both input arrays (curried version).
 * @template T
 * @param {T[]} arrB - The second input array.
 * @returns {(arrA: T[]) => T[]} - A function that takes the first array and returns a new array containing elements from both input arrays.
 */
declare function concat<T>(arrB: T[]): (arrA: T[]) => T[]

// ---
/**
 * Groups the elements of the input array based on the result of the group function.
 * @template A
 * @template B
 * @param {A[]} arr - The input array.
 * @param {(item: A) => A[B]} groupFn - The function to determine the grouping.
 * @returns {Partial<Record<PropertyKey, readonly [A, ...A[]]>>} - A partial record of grouped elements.
 */
declare function groupBy<A extends object, B extends keyof A>(
	arr: A[],
	groupFn: (item: A) => A[B],
): Partial<Record<PropertyKey, readonly [A, ...A[]]>>

/**
 * Groups the elements of the input array based on the result of the group function (curried version).
 * @template A
 * @template B
 * @param {(item: A) => A[B]} groupFn - The function to determine the grouping.
 * @returns {(arr: A[]) => Partial<Record<PropertyKey, readonly [A, ...A[]]>} - A function that takes an array and returns a partial record of grouped elements.
 */
declare function groupBy<A extends object, B extends keyof A>(
	groupFn: (item: A) => A[B],
): (arr: A[]) => Partial<Record<PropertyKey, readonly [A, ...A[]]>>

// ---
/**
 * Applies a function to each element of the input array.
 * @template A
 * @param {A[]} arr - The input array.
 * @param {(value: A) => void} fn - The function to apply to each element.
 * @returns {void}
 */
declare function forEach<A>(arr: A[], fn: (value: A) => void): void
/**
 * Applies a function to each element of the input array (curried version).
 * @template A
 * @template B
 * @param {(value: A) => void} fn - The function to apply to each element.
 * @returns {(arr: A[]) => void} - A function that takes an array and applies the function to each element.
 */
declare function forEach<A>(fn: (value: A) => void): (arr: A[]) => void

// ---
/**
 * Applies a function to each element of the input array along with its index.
 * @template A
 * @param {A[]} arr - The input array.
 * @param {(value: A, index: number) => void} fn - The function to apply to each element along with its index.
 * @returns {void}
 */
declare function forEachIndexed<A>(arr: A[], fn: (value: A, index: number) => void): void

/**
 * Applies a function to each element of the input array along with its index (curried version).
 * @template A
 * @param {(value: A, index: number) => void} fn - The function to apply to each element along with its index.
 * @returns {(arr: A[]) => void} - A function that takes an array and applies the function to each element along with its index.
 */
declare function forEachIndexed<A>(fn: (value: A, index: number) => void): (arr: A[]) => void

// ---
/**
 * Applies a mapping function to each element of the input array and returns a new array with the results.
 * Functor implementation for Arrays
 * @template A
 * @template B
 * @param {A[]} arr - The input array.
 * @param {(value: A) => B} mapFn - The mapping function to apply to each element.
 * @returns {B[]} - The new array with the results of applying the mapping function.
 */
declare function map<A, B>(arr: A[], mapFn: (value: A) => B): B[]

/**
 * Applies a mapping function to each element of the input array and returns a new array with the results (curried version).
 * @template A
 * @template B
 * @param {(value: A) => B} mapFn - The mapping function to apply to each element.
 * @returns {(arr: A[]) => B[]} - A function that takes an array and returns a new array with the results of applying the mapping function.
 */
declare function map<A, B>(mapFn: (value: A) => B): (arr: A[]) => B[]

// ---
/**
 * Maps the elements of an array to a new array using the provided mapping function, which also takes the index of the current element into account.
 * @template A, B
 * @param {A[]} arr - The input array to be mapped.
 * @param {(value: A, index: number) => B} mapFn - The mapping function that takes the value and index of the current element and returns the mapped value.
 * @returns {B[]} - The new array with the mapped values.
 */
declare function mapIndexed<A, B>(arr: A[], mapFn: (value: A, index: number) => B): B[]

/**
 * Maps the elements of an array to a new array using the provided mapping function, which also takes the index of the current element into account (curried version).
 * @template A, B
 * @param {(value: A, index: number) => B} mapFn - The mapping function that takes the value and index of the current element and returns the mapped value.
 * @returns {(arr: A[]) => B[]} - A curried function that takes an array and returns a new array with the mapped values.
 */
declare function mapIndexed<A, B>(mapFn: (value: A, index: number) => B): (arr: A[]) => B[]

// ---
/**
 * Filters the elements of an array based on the provided predicate function.
 * @template A
 * @param {A[]} arr - The input array to be filtered.
 * @param {(value: A) => boolean} predicateFn - The predicate function that returns true for elements to be included in the filtered array.
 * @returns {A[]} - The new array with the filtered elements.
 */
declare function filter<A>(arr: A[], predicateFn: (value: A) => boolean): A[]

/**
 * Filters the elements of an array based on the provided predicate function (curried version).
 * @template A
 * @param {(value: A) => boolean} predicateFn - The predicate function that returns true for elements to be included in the filtered array.
 * @returns {(arr: A[]) => A[]} - A curried function that takes an array and returns a new array with the filtered elements.
 */
declare function filter<A>(predicateFn: (value: A) => boolean): (arr: A[]) => A[]

// ---
/**
 * Filters the elements of an array based on the provided predicate function, which also takes the index of the current element into account.
 * @template A
 * @param {A[]} arr - The input array to be filtered.
 * @param {(value: A, index: number) => boolean} predicateFn - The predicate function that returns true for elements to be included in the filtered array.
 * @returns {A[]} - The new array with the filtered elements.
 */
declare function filterIndexed<A>(arr: A[], predicateFn: (value: A, index: number) => boolean): A[]

/**
 * Filters the elements of an array based on the provided predicate function, which also takes the index of the current element into account (curried version).
 * @template A
 * @param {(value: A, index: number) => boolean} predicateFn - The predicate function that returns true for elements to be included in the filtered array.
 * @returns {(arr: A[]) => A[]} - A curried function that takes an array and returns a new array with the filtered elements.
 */
declare function filterIndexed<A>(predicateFn: (value: A, index: number) => boolean): (arr: A[]) => A[]

// ---
/**
 * Chains the result of applying a function to each element of the array into a single array.
 * Monad implementation for Arrays
 * @template T, U
 * @param {T[]} arr - The input array to be chained.
 * @param {(item: T) => U[]} fn - The function that takes an element of the array and returns an array of transformed elements.
 * @returns {U[]} - The single array resulting from chaining the transformed elements.
 */
declare function chain<T, U>(arr: T[], fn: (item: T) => U[]): U[]

/**
 * Chains the result of applying a function to each element of the array into a single array (curried version).
 * Monad implementation for Arrays
 * @template T, U
 * @param {(item: T) => U[]} fn - The function that takes an element of the array and returns an array of transformed elements.
 * @returns {(arr: T[]) => U[]} - A curried function that takes an array and returns the single array resulting from chaining the transformed elements.
 */
declare function chain<T, U>(fn: (item: T) => U[]): (arr: T[]) => U[]

// ---
/**
 * Chains the result of applying a function to each element of the array, taking the index into account, into a single array.
 * @template T, U
 * @param {T[]} arr - The input array to be chained.
 * @param {(item: T, index: number) => U[]} fn - The function that takes an element and its index in the array, and returns an array of transformed elements.
 * @returns {U[]} - The single array resulting from chaining the transformed elements.
 */
declare function chainIndexed<T, U>(arr: T[], fn: (item: T, index: number) => U[]): U[]

/**
 * Chains the result of applying a function to each element of the array, taking the index into account, into a single array (curried version).
 * @template T, U
 * @param {(item: T, index: number) => U[]} fn - The function that takes an element and its index in the array, and returns an array of transformed elements.
 * @returns {(arr: T[]) => U[]} - A curried function that takes an array and returns the single array resulting from chaining the transformed elements.
 */
declare function chainIndexed<T, U>(fn: (item: T, index: number) => U[]): (arr: T[]) => U[]

// ---
/**
 * Applies a function to each element of the array, accumulating the result, and returning the final accumulated value.
 * @template A, B
 * @param {A[]} arr - The input array to be folded.
 * @param {(prev: B, item: A) => B} fn - The function that takes the previous accumulated value and the current element, and returns the new accumulated value.
 * @param {B} init - The initial value for the accumulation.
 * @returns {B} - The final accumulated value.
 */
declare function fold<A, B>(arr: A[], fn: (prev: B, item: A) => B, init: B): B

/**
 * Applies a function to each element of the array, accumulating the result, and returning the final accumulated value (curried version).
 * @template A, B
 * @param {(prev: B, item: A) => B} fn - The function that takes the previous accumulated value and the current element, and returns the new accumulated value.
 * @param {B} init - The initial value for the accumulation.
 * @returns {(arr: A[]) => B} - A curried function that takes an array and returns the final accumulated value.
 */
declare function fold<A, B>(fn: (prev: B, item: A) => B, init: B): (arr: A[]) => B

// ---
/**
 * Applies a function to each element of the array, accumulating the result, taking the index into account, and returning the final accumulated value.
 * @template A, B
 * @param {A[]} arr - The input array
 * @param {(prev: B, item: A, index: number) => B} fn - The function to apply to each element
 * @param {B} init - The initial value
 * @returns {B} - The reduced value
 */
declare function foldIndexed<A, B>(arr: A[], fn: (prev: B, item: A, index: number) => B, init: B): B

/**
 * Applies a function to each element of the array, accumulating the result, taking the index into account, and returning the final accumulated value (curried version).
 * @template A, B
 * @param {(prev: B, item: A, index: number) => B} fn - The function to apply to each element
 * @param {B} init - The initial value
 * @returns {(arr: A[]) => B} - A curried function that takes an array and returns the final accumulated value.
 */
declare function foldIndexed<A, B>(fn: (prev: B, item: A, index: number) => B, init: B): (arr: A[]) => B

// ---
/**
 * Applies a list of functions to a list of items and returns the results.
 * Applicative implementation for Array
 * @template T, U
 * @param {((item: T) => U)[]} fns - An array of functions to apply to the items.
 * @param {T[]} list - The list of items to apply the functions to.
 * @returns {U[]} - An array of results after applying the functions to the items.
 */
declare function ap<T, U>(fns: ((item: T) => U)[], list: T[]): U[]

/**
 * Applies a list of functions to a list of items and returns the results (curried version).
 * Applicative implementation for Array
 * @template T
 * @param {T[]} list - The list of items to apply the functions to.
 * @returns {(fns: ((item: T) => U)[]) => U[]} - A function that takes an array of functions and returns an array of results after applying the functions to the items.
 */
declare function ap<T>(list: T[]): <U>(fns: ((item: T) => U)[]) => U[]

// ---
/**
 * Transforms a list of Maybe values into a Maybe value of a list.
 * @template A
 * @param {Maybe<A>[]} maybeArr - The array of Maybe values to transform.
 * @returns {Maybe<A[]>} - A Maybe value containing an array of transformed values.
 */
declare function sequenceMaybe<A>(maybeArr: Maybe<A>[]): Maybe<A[]>

// ---
/**
 * Traverses a list of items with a function that may produce Maybe values and returns a Maybe value of a list.
 * @template A, B
 * @param {A[]} arr - The list of items to traverse.
 * @param {(item: A) => Maybe<B>} f - The function that may produce Maybe values.
 * @returns {Maybe<B[]>} - A Maybe value containing an array of transformed values.
 */
declare function traverseMaybe<A, B>(arr: A[], f: (item: A) => Maybe<B>): Maybe<B[]>

/**
 * Traverses a list of items with a function that may produce Maybe values and returns a Maybe value of a list (curried version).
 * @template A, B
 * @param {(item: A) => Maybe<B>} f - The function that may produce Maybe values.
 * @returns {(arr: A[]) => Maybe<B[]>} - A function that takes a list of items and returns a Maybe value containing an array of transformed values.
 */
declare function traverseMaybe<A, B>(f: (item: A) => Maybe<B>): (arr: A[]) => Maybe<B[]>

// ---
/**
 * Transforms a list of Either values into an Either value of a list.
 * @template E, A
 * @param {Either<E, A>[]} eitherArr - The array of Either values to transform.
 * @returns {Either<E, A[]>} - An Either value containing a transformed array of values.
 */
declare function sequenceEither<E, A>(eitherArr: Either<E, A>[]): Either<E, A[]>

// ---
/**
 * Traverses a list of items with a function that may produce Either values and returns an Either value of a list.
 * @template E, S, T
 * @param {S[]} arr - The list of items to traverse.
 * @param {(item: S) => Either<E, T>} f - The function that may produce Either values.
 * @returns {Either<E, T[]>} - An Either value containing a transformed array of values.
 */
declare function traverseEither<E, S, T>(arr: S[], f: (item: S) => Either<E, T>): Either<E, T[]>

/**
 * Traverses a list of items with a function that may produce Either values and returns an Either value of a list (curried version).
 * @template E, S, T
 * @param {(item: S) => Either<E, T>} f - The function that may produce Either values.
 * @returns {(arr: S[]) => Either<E, T[]>} - A function that takes a list of items and returns an Either value containing a transformed array of values.
 */
declare function traverseEither<E, S, T>(f: (item: S) => Either<E, T>): (arr: S[]) => Either<E, T[]>

// ---
/**
 * Transforms a list of Task values into a Task value of a list.
 * @template E, A
 * @param {Task<E, A>[]} taskArr - The array of Task values to transform.
 * @returns {Task<E, A[]>} - A Task value containing a transformed array of values.
 */
declare function sequenceTask<E, A>(taskArr: Task<E, A>[]): Task<E, A[]>

// ---
/**
 * Traverses a list of items with a function that produces Task values and returns a Task value of a list, in an applicative way wich means that all tasks are executed concurrently.
 * @template E, S, T
 * @param {S[]} arr - The list of items to traverse.
 * @param {(item: S) => Task<E, T>} f - The function that produces Task values.
 * @returns {Task<E, T[]>} - A Task value containing a transformed array of values.
 */
declare function traverseTaskA<E, S, T>(arr: S[], f: (item: S) => Task<E, T>): Task<E, T[]>

/**
 * Traverses a list of items with a function that produces Task values and returns a Task value of a list, in an applicative way wich means that all tasks are executed concurrently (curried version).
 * @template E, S, T
 * @param {(item: S) => Task<E, T>} f - The function that produces Task values.
 * @returns {(arr: S[]) => Task<E, T[]>} - A function that takes a list of items and returns a Task value containing a transformed array of values.
 */
declare function traverseTaskA<E, S, T>(f: (item: S) => Task<E, T>): (arr: S[]) => Task<E, T[]>

// ---
/**
 * Traverses a list of items with a function that produces Task values and returns a Task value of a list, in a monadic way wich means that all tasks are executed sequentially.
 * @template E, S, T
 * @param {S[]} arr - The list of items to traverse.
 * @param {(item: S) => Task<E, T>} f - The function that produces Task values.
 * @returns {Task<E, T[]>} - A Task value containing a transformed array of values.
 */
declare function traverseTaskM<E, S, T>(arr: S[], f: (item: S) => Task<E, T>): Task<E, T[]>

/**
 * Traverses a list of items with a function that produces Task values and returns a Task value of a list, in a monadic way wich means that all tasks are executed sequentially (curried version).
 * @template E, S, T
 * @param {(item: S) => Task<E, T>} f - The function that produces Task values.
 * @returns {(arr: S[]) => Task<E, T[]>} - A function that takes a list of items and returns a Task value containing a transformed array of values.
 */
declare function traverseTaskM<E, S, T>(f: (item: S) => Task<E, T>): (arr: S[]) => Task<E, T[]>

// @ts-ignore
declare const Arr = {
	of,
	make,
	makeWithIndex,
	isEmpty,
	size,
	head,
	headOrNull,
	tail,
	all,
	any,
	some,
	find,
	findOrNull,
	at,
	atOrNull,
	removeAt,
	take,
	reverse,
	cons,
	snoc,
	concat,
	groupBy,
	forEach,
	forEachIndexed,
	map,
	mapIndexed,
	filter,
	filterIndexed,
	chain,
	chainIndexed,
	fold,
	foldIndexed,
	sequenceMaybe,
	sequenceEither,
	sequenceTask,
	traverseMaybe,
	traverseEither,
	traverseTaskA,
	traverseTaskM,
	ap,
}

export { Arr }
